#include "DYN08.h"

int main()
{
	int m; // Количество вершин - m
	int X, Y; // Координаты точки вращения
	double** P = new double*[3]; // Массив из вершин
	double** P1 = new double*[3];
	double** P2 = new double*[3];
	double** P3 = new double*[3];
	double** P4 = new double*[3];
	double** FM = new double* [3];
	double F; // Угол поворота
	int h; // Расстояние перемешения фигуры

	fstream f;

	f.open("input.txt", ios_base::in); // Считывание количества вершин с потока
	f >> m;


	/////////////////////////////////////// Объявление массивов ///////////////////////////////////////
	P[0] = new double[m];	// Массив координат Х
	P[1] = new double[m];	// Массив координат Y
	P[2] = new double[m];	// Массив нормирующего коэффициента



	P1[0] = new double[m];	// Массив координат Х
	P1[1] = new double[m];	// Массив координат Y
	P1[2] = new double[m];	// Массив нормирующего коэффициента



	P2[0] = new double[m];	// Массив координат Х
	P2[1] = new double[m];	// Массив координат Y
	P2[2] = new double[m];	// Массив нормирующего коэффициента

	for (int i = 0; i < 3; i++)
	{
		P3[i] = new double[m];
	}


	for (int i = 0; i < 3; i++)
	{
		P4[i] = new double[m];
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////

	for (int j = 0; j < m; j++) // Считываем массив из файла
	{
		f >> P[0][j];
		f >> P[1][j];
		f >> P[2][j];
	}


	for (int j = 0; j < m; j++) // Outnput in the consol
	{
		for (int i = 0; i < 3; i++)
		{
			cout << P[i][j] << " ";
		}
		cout << endl;
	}
	 
	cout << endl;

	//////////////////////////////// Создаем единичную матрицу //////////////////////////////////////

	/*
		Создаю именно здесь, а не в DYN08.cpp чтоб не возникало проблем с идентификацией изменений элементов единичной матрицы.
		Работает, и пусть работаетю... Зачем рабочий костыль ломать?)))
	*/

	double **E = new double*[3]; 

	for (int i = 0; i < 3; i++)
	{
		E[i] = new double[m]; // Создание массива столбцов
	}


	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < m + 1; j++)
		{
			if (i == j) // Диагональные элементы
				E[i][j] = 1;
			else
				E[i][j] = 0;
			cout << E[i][j] << " ";
		}
		cout << endl;
	}
	
	//////////////////////////////////// Задаем точку (из)вращения /////////////////////////////////////

	cout << endl;
	cout << "Enter the coordinates of an arbitrary point (X, Y): " << endl; // Вводим координаты точки вращения
	cin >> X;
	cin >> Y;
	cout << endl;


	E[0][m-1] = -X; //Перенос центра вращения треугольника из произвольной точки в начало координат
	E[1][m-1] = -Y;


	Output_E(m, E);


	Multiply_Matrix(P1, P, E, m);


	for (int j = 0; j < m; j++) // Outnput in the consol
	{
		cout << endl;

		for (int i = 0; i < 3; i++)
		{
			cout << P1[i][j] << " ";
		}
	}

	cout << endl;
	cout << endl << "Enter angle of rotation: ";
	cin >> F;
	cout << endl;

	
	//////////////////////////////// Создаем матрицу вращения ////////////////////////////////////////

	/*
		double *R[3][3] = { {cos(F),	sin(F),		0},
							{-sin(F),	cos(F),		0},
							{0	,		0,			1} };
	*/

	double **R = new double*[3]; 

	for (int i = 0; i < 3; i++)
	{
		R[i] = new double[m]; 
	}


	for (int i = 0; i < 3; i++) // Как и единичная, но с правками на синус и косинус
	{
		for (int j = 0; j < m + 1; j++)
		{
			if (i == j)
				R[i][j] = 1;
			else
				R[i][j] = 0;
		}
		cout << endl;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////

	F = F * (3.1415926 / 180); // Намучился с этим уже когда-то... sin() и cos() возвращают значения в радианах. Значит здесь делаем перевод в градусы.

	///////////////////////////////////////////////////////////////////////////////////////////////

	R[0][0] = cos(F); // Вот, собственно, и сами правки
	R[0][1] = -sin(F);

	R[1][0] = sin(F);
	R[1][1] = cos(F);

	////////////////////////////////////////////////////////////////////////////////////////////////

	for (int j = 0; j < m; j++) 
	{
		cout << endl;

		for (int i = 0; i < 3; i++)
		{
			cout << R[i][j] << " ";
		}
	}
	cout << endl;

	////////////////////////////////////////////////////////////////////////////////////////////////

	Rotate(P2, P1, R, m);

	////////////////////////////////////////////////////////////////////////////////////////////////

	for (int j = 0; j < m; j++) 
	{
		cout << endl;

		for (int i = 0; i < 3; i++)
		{
			cout << P2[i][j] << " ";
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////


	E[0][m - 1] = X; // Перенос центра вращения обратно
	E[1][m - 1] = Y;

	////////////////////////////////////////////////////////////////////////////////////////////////

	Output_E(m, E);

	////////////////////////////////////////////////////////////////////////////////////////////////

	Multiply_Matrix2(P4, E, P2, m);

	///////////////////////////////// Вывод фигуры после вращения //////////////////////////////////  

	for (int j = 0; j < m; j++) 
	{
		cout << endl;

		for (int i = 0; i < 3; i++)
		{
			cout << P4[i][j] << " ";
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	cout << endl;
	cout << "Enter the range h: " << endl; 
	cin >> h;
	///////////////////////////////////////////////////////////////////////////////////////////////

	Transfer(m, h, FM, P4);
	
	///////////////////////////////////////////////////////////////////////////////////////////////

	Output_Final_Matrix(m, FM, P4);


	/* Удаление массива
	for (int i = 0; i < m; i++)
	{
		delete[] E[i]; // Удаляем каждый элемент
	}
	delete[] E; // А потом массив
	*/

	return 0;
}